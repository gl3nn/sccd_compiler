<?xml version="1.0" ?>
<diagram author="Glenn De Jonghe" name="AI Tank">
    <description>
        Handling the npc tank.
    </description>
    <inport name="engine" />
    
    <top>
        from AIMap import AIMap
        import math
    </top>
    
    <!--  constructor  -->
    <class name="Main" default="true">
        <attribute name="tank" type="AITank"/>
        <attribute name="map" type="AIMap"/>
        <method name="Main">
            <parameter type="AITank" name="tank"></parameter>
            <body>
                self.tank = tank
                self.map = AIMap(tank.field.level)
           </body>
        </method>
        <relationships>
            <association class="Cannon" name="cannon" min="1" max="1"/>
            <association class="Body" name="body" min="1" max="1"/>
        </relationships>
        <scxml initial="start">
            <state id="start">
                <transition target="../check">
                    <raise event="create_instance" scope="CD">
                        <parameter expr="'cannon'"/>
                        <parameter expr="SELF.tank"/>
                    </raise>
                    <raise event="create_instance" scope="CD">
                        <parameter expr="'body'"/>
                        <parameter expr="SELF.tank"/>
                    </raise>
                </transition>
            </state>
            <state id="check">
            
            </state>
        </scxml>
    </class>
    
    <!-- sensor -->
    
    <class name="Radar">
        <attribute name="tank" type="PlayerTank"/>
        <attribute name="range" type="float" init-value="500"/>
        <method name="Radar">
            <parameter type="AITank" name="tank"></parameter>
            <body>
                self.tank = tank
           </body>
        </method>
        <method name="isEnemyVisible" type="bool">
            <body>
        		sighted_list = self.field.getSightedEnemies(self.tank, self.range)
        		if len(sighted_list) > 0 :
        			return True
        		return False
            </body>
        </method>
        <method name="getEnemyPos" type="bool">
            <body>
                sighted_list = self.tank.field.getSightedEnemies(self.tank, self.range)
                if len(sighted_list) > 0 :
                    sighted_list.sort(key=lambda x: x[1])
                    return sighted_list[0]
                else :
                    return (0,0)
            </body>
        </method>
        <scxml>
            <state id="no_enemy">
                <transition guard="SELF.isEnemyVisible()" target="../enemy_in_sight">
                    <raise event="enemy_sighted" scope="broad">
                        <parameter value="SELF.getEnemyPos()"/>
                    </raise>
                </transition>
            </state>
            <state id="enemy_in_sight">
                <transition guard="not SELF.isEnemyVisible()" target="../no_enemy">
                    <raise event="enemy_out_of_sight" scope="broad"/>
                </transition>
                <transition 
            </state>
        </scxml>
    </class>
    
    <!-- Memorizers -->
    
    <class name="EnemyTracker">
        <attribute name="enemy_pos" type="Position"/>
        <method name="hasEnemyMoved()">
            <parameter name="new_position"
            <body>
                return new_position != enemy_pos
           </body>
        </method>
        <scxml initial="no_enemy">
            <state id="no_enemy">
                <transition event="enemy_sighted" target="../enemy_pos_known"> 
                    <parameter name="enemy_position"/>
                    <script>
                        self.enemy_pos = enemy_position
                    </script>
                </transition>
            </state>
            <state id="enemy_pos_known">
                <transition event="enemy_pos" guard="hasEnemyMoved(position)" target=".">
                    <parameter name="position"/>
                    <script>
                        self.enemy_pos = position
                    </script>
                    <raise event="enemy_pos_changed" scope="broad">
                        <parameter value="SELF.enemy_pos"/>
                    </raise>
                </transition>
                <transition event="enemy_out_of_sight" target="../enemy_pos_unsure"/>
            </state>
            <state id="enemy_pos_unsure">
                <transition event="destination_reached" target="../no_enemy">
                    <raise event="enemy_lost"/>
                </transition>
                <transition event="enemy_sighted" target="../enemy_pos_known"> 
                    <parameter name="position"/>
                    <script>
                        self.enemy_pos = enemy_position
                    </script>
                </transition>
            </state>
            
            
        
        </scxml>
    </class>
    
    <!-- strategic deciders -->
    
    <class name="PilotStrategy">
        <scxml initial="exploring">
            <state id="exploring">
                <onentry>
                    <raise event="explore"/>
                </onentry>
                <onexit>
                    <raise event="stop_exploring"/>
                </onexit>
                <transition event="enemy_sighted" target="../attacking">
                    <parameter name="position"/>
                    <raise event="attack">
                        <parameter value="position"/>
                    </raise>
                </transition>
            </state>
            <state id="attacking">
                <onexit>
                    <raise event="stop_attacking"/>
                </onexit>
                <transition event="enemy_lost" target="../exploring"/>
            </state>
        </scxml>
    </class>
    
    <!-- tactical deciders -->
    
    <class name="ExplorePlanner">
        <scxml initial="no_destination">
            <state id="no_destination">
                <transition target="../exploring">
                    setdesti
                </transition>
            </state>
            <state id="exploring">
                <transition event="destination_reached" target="../no_destination"/>
            </state>
        </scxml>
    
    </class>
    
    <class name="AttackPlanner">
        <relationships>
            <association class="TurretSteering" name="turret_steer" min="1" max="1"/>
        </relationships>
        <scxml initial="idle">
            <state id="idle">
                <transition event="attack" target="../action">
                    <parameter name="enemy_pos"/>
                    <raise event="new_destination" scope="broad">
                        <parameter value="enemy_pos"/>
                    </raise>
                    <raise event="aim" target="turret_steer">
                        <parameter value="enemy_pos"/>
                    </raise>
                </transition>
            </state>
            <parallel id="action">
                <transition event="stop_attack" target="../idle">
                    <raise event="stop_aim" target="turret_steer"/>
                </transition>
                <state id="movement">
                    <state id="following">
                        <transition event="enemy_pos_changed" target=".">
                            <parameter name="enemy_pos"/>
                            <raise event="new_destination" scope="broad">
                                <parameter value="enemy_pos"/>
                            </raise>
                            <raise event="aim" target="turret_steer">
                                <parameter value="enemy_pos"/>
                            </raise>
                        </transition>
                    </state>
                </state>
                <state id="shooting">
                    <state id="loaded">
                        <transition event="ready_to_shoot" target="../reloading">
                            <raise event="shoot" scope="broad"/>
                        </transition>
                    </state>
                    <state id="reloading">
                        <transition after="1" target="../loaded"/>
                    </state>
                </state>
            </parallel>
        </scxml>
    </class>
    
    <class name="PathFinder">
        <method name="calculatePath">
            <body>
            
            </body>
        </method>
        <method name="requiresNewPath">
            <body>
            
            </body>
        </method>
        <method name="morePoints">
            return len(self.waypoints) > 0
        </method>
        <attribute name="waypoints"/>
        <attribute name="destination"/>
        <attribute name="map"/>
        <scxml initial="idle">
            <state id="idle">    
                <transition event="waypoint_reached" target="../point_reached">
                
                </transition>
                <transition event="new_destination" guard="requiresNewPath()" target=".">
                    <parameter name="destination"/>
                    <script>
                        self.destination = destination
                        self.waypoints = self.calculatePath()
                    </script>
                    <raise event="new_waypoint">
                        <parameter value="SELF.waypoints[0]"/>
                    </raise>
                </transition>
            </state>
            <state id="point_reached">
                <transition guard=" SELF.moreWaypoints()" target="../idle">
                    <raise event="new_waypoint">
                        <parameter value="next waypoint"/>
                    </raise>
                </transition>
                <transition guard="not SELF.moreWaypoints()" target="../idle">
                    <raise event="destination_reached"/>
                </transition>
            </state>
        </scxml>
    </class>
    
    <!-- executors -->
    
    
    <class name="Steering">
        <attribute name="dest_waypoint"/>
        <attribute name="dest_cell"/>
        <attribute name="reaction_time" init-value="0.05"/>
        <attribute name="tank"/>
        <attribute name="map" />
        <attribute name="margin" init-value="0.2"/>
        <method name="pointReached">
            <body>
                cell = map.calculateCell((self.tank.x, self.tank.y))
                return cell == dest_cell
            </body>
        </method>
        <method name="pointAhead">
            <body>
                goal_angle = self.tank.angleToDest(dest_waypoint)
                diff = math.fabs(self.tank.angle - goal_angle)
                if diff <= (D45) :
                    self.tank.moveSpeed = int(math.ceil(((D45 - diff) / D45) * self.maxMoveSpeed))
                    return True
                if diff >= (D360 - D45) :
                    self.tank.moveSpeed = int(math.ceil(((diff - (D360 - D45)) / D45) * self.maxMoveSpeed))
                    return True
                return False
            </body>
        </method>
        <method name="pointBehind">
            <body>
                goal_angle = self.tank.angleToDest(dest_waypoint)
                diff = math.fabs(self.tank.angle - goal_angle)
                if diff < (D45) or diff > (D360 - D45) :
                    return False
                return True
            </body>
        </method>
        <method name="pointLeft">
            <body>
                goal_angle = self.tank.angleToDest(dest_waypoint)
                diff = (self.tank.angle - goal_angle) % D360
                if diff >= self.margin and diff <= math.pi:
                    return True
                return False
            </body>
        </method>
        <method name="pointRight">
            <body>
                goal_angle = self.tank.angleToDest(dest_waypoint)
                diff = (goal_angle - self.tank.angle) % D360
                if diff >= self.margin and diff <= math.pi:
                    return True
                return False
            </body>
        </method>
        <method name="pointStraight">
            <body>
                goal_angle = self.tank.angleToDest(dest_waypoint)
                diff = math.fabs(self.tank.angle - goal_angle)
                if diff < self.margin or diff > (D360- self.margin) :
                    return True
                return False
            </body>
        </method>
        <scxml initial="idle">
            <state id="idle">
                <transition event="new_waypoint" target="../steering">
                    <parameter name="dest_waypoint"/>
                    <script>
                        self.dest_waypoint = dest_waypoint
                        self.dest_cell = map.calculateCell(dest_waypoint)
                    </script>
                </transition>
            </state>
            <state id="steering" initial="forward_backward">
                <transition guard="SELF.pointReached()" target="idle">
                    <raise event="waypoint_reached" scope="broad"/>
                </transition>
                
                <state id="forward_backward">
                    <transition guard="pointAhead()" target="left_right">
                        <raise event="forward"/>
                    </transition>
                    <transition guard="pointBehind()" target="left_right">
                        <raise event="stop"/>
                    </transition>
                </state>
                <state id="left_right">
                    <transition guard="pointStraight()" target="wait">
                        <raise event="stop_turning"/>
                    </transition>
                    <transition guard="pointLeft()" target="wait">
                        <raise event="turn_left"/>
                    </transition>
                    <transition guard="pointRight()" target="wait">
                        <raise event="turn_right"/>
                    </transition>
                </state>
                <state id="wait">
                    <transition after="SELF.reaction_time" target="../forward_backward"/>
                </state>
                
            </state>
        </scxml>
    </class>
        
    <class name="TurretSteering">
        <attribute name="reaction_time" init-value="0.05"/>
        <attribute name="tank"/>
        <attribute name="margin" init-value="0.2"/>
        <atribute name="target"/>
        <relationships>
            <association class="TurretControl" name="turret_control" min="1" max="1"/>
        </relationships>
        <scxml initial="idle">
            <state id="idle">
                <transition event="aim_at" target="../aiming">
                    <parameter name="target"/>
                    <script>
                        self.target = target
                    </script>
                </transition>
            </state>
            <state id="aiming" initial="adjust">
                <transition event="stop_aiming" target="../idle">
                </transition>
                
                <state id="adjust">
                    <transition guard="pointAhead()" target="left_right">
                        <raise event="forward"/>
                    </transition>
                    <transition guard="pointBehind()" target="left_right">
                        <raise event="stop"/>
                    </transition>
                </state>
                <state id="wait">
                    <transition after="SELF.reaction_time" target="../forward_backward"/>
                </state>
                
            </state>
        </scxml>
        
    
    </class>
        
    <!-- coordinators -->
        
    <!-- actuators  -->
        
    <class name="MotorControl">
        <attribute name="tank"/>
        <scxml>
            <parallel id="control">
                <state id="left_right" initial="stop">
                    <state id="stop">
                        <transition event="forward" target="../going_forward"/>
                        <transition event="backward" target="../going_backward"/>
                    </state>
                    <state id="going_forward">
                        <transition event="stop" target="../stop"/>
                        <transition event="backward" target="../going_backwardt"/>
                        <transition event="update" port="engine" target=".">
                            <script>
                                tank.moveUp()
                            </script>
                        </transition>
                    </state>
                    <state id="going_backward">
                        <transition event="stop" target="../stop"/>
                        <transition event="forward" target="../going_forward"/>
                        <transition event="update" port="engine" target=".">
                            <script>
                                tank.moveDown()
                            </script>
                        </transition>
                    </state>
                </state>
                <state id="forward_backward" initial="straight">
                    <state id="straight">
                        <transition event="turn_right" target="../turning_right"/>
                        <transition event="turn_left" target="../turning_left"/>
                    </state>
                    <state id="turning_left">
                        <transition event="stop_turning" target="../straight"/>
                        <transition event="turn_right" target="../turning_right"/>
                        <transition event="update" port="engine" target=".">
                            <script>
                                tank.turnLeft()
                            </script>
                        </transition>
                    </state>
                    <state id="turning_right">
                        <transition event="stop_turning" target="../straight"/>
                        <transition event="turn_left" target="../turning_left"/>
                        <transition event="update" port="engine" target=".">
                            <script>
                                tank.turnRight()
                            </script>
                        </transition>
                    </state>
                </state>
            </parallel>
        </scxml>
    </class>
    
    <class name="CannonControl">
        <attribute name="tank"/>
        <scxml initial="none">
            <state id="none">
                <transition event="turn_right" target="../turning_right"/>
                <transition event="turn_left" target="../turning_left"/>
            </state>
            <state id="turning_left">
                <transition event="stop_turning" target="../straight"/>
                <transition event="turn_right" target="../turning_right"/>
                <transition event="update" port="engine" target=".">
                    <script>
                        tank.turnCannonLeft()
                    </script>
                </transition>
            </state>
            <state id="turning_right">
                <transition event="stop_turning" target="../straight"/>
                <transition event="turn_left" target="../turning_left"/>
                <transition event="update" port="engine" target=".">
                    <script>
                        tank.turnCannonRight()
                    </script>
                </transition>
            </state>
        </scxml>
    </class>
    
    
</diagram>
